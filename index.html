<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>首頁 - 彩繪玻璃動態背景</title>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #stained-glass-bg {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      z-index: -1;
      display: block;
    }
    h1, p { position: relative; z-index: 1; color: #222; text-shadow: 0 0 8px #fff, 0 0 2px #fff; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6.0.2/dist/d3-delaunay.min.js"></script>
</head>
<body>
  <canvas id="stained-glass-bg"></canvas>
  <h1>歡迎</h1>
  <p>這是彩繪玻璃動態背景效果</p>
  <script>
    const canvas = document.getElementById('stained-glass-bg');
    const ctx = canvas.getContext('2d');
    let dpr = window.devicePixelRatio || 1;
    let w = window.innerWidth, h = window.innerHeight;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // 產生隨機點作為多邊形中心
    const CELL_COUNT = 64;
    let points = [];
    function randomPoints() {
      points = [];
      for (let i = 0; i < CELL_COUNT; i++) {
        points.push({
          x: Math.random() * w,
          y: Math.random() * h,
          hue: Math.random() * 360,
          speed: Math.random() * 0.2 + 0.05
        });
      }
    }
    randomPoints();

    function drawVoronoi() {
      ctx.clearRect(0, 0, w, h);

      // 動態調整每個點的色相
      for (let p of points) {
        p.hue = (p.hue + p.speed) % 360;
      }

      // 用 d3-delaunay 計算 Voronoi
      const delaunay = d3.Delaunay.from(points, d => d.x, d => d.y);
      const voronoi = delaunay.voronoi([0, 0, w, h]);

      for (let i = 0; i < points.length; i++) {
        const cell = voronoi.cellPolygon(i);
        if (!cell) continue;
        let p = points[i];
        let hue = p.hue;
        let sat = 75;
        let light = 60;
        let color = hslToRgb(hue/360, sat/100, light/100);

        ctx.beginPath();
        ctx.moveTo(cell[0][0], cell[0][1]);
        for (let j = 1; j < cell.length; j++) {
          ctx.lineTo(cell[j][0], cell[j][1]);
        }
        ctx.closePath();
        ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
        ctx.fill();

        // 畫圓滑黑邊
        ctx.save();
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 2.2;
        ctx.shadowColor = "#000";
        ctx.shadowBlur = 2;
        ctx.stroke();
        ctx.restore();
      }

      requestAnimationFrame(drawVoronoi);
    }

    // HSL to RGB helper
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s == 0) {
        r = g = b = l;
      } else {
        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        }
        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
    }

    window.addEventListener('resize', () => {
      dpr = window.devicePixelRatio || 1;
      w = window.innerWidth;
      h = window.innerHeight;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      randomPoints();
    });

    drawVoronoi();
  </script>
</body>
</html>
</body>
</html>