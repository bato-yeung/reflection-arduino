<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>首頁 - 彩繪玻璃動態背景</title>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #stained-glass-bg {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      z-index: -1;
      display: block;
    }
    h1, p { position: relative; z-index: 1; color: #222; text-shadow: 0 0 8px #fff, 0 0 2px #fff; }
  </style>
</head>
<body>
  <canvas id="stained-glass-bg"></canvas>
  <h1>歡迎</h1>
  <p>這是彩繪玻璃動態背景效果</p>
  <script>
    const canvas = document.getElementById('stained-glass-bg');
    const ctx = canvas.getContext('2d');
    let dpr = window.devicePixelRatio || 1;
    let w = window.innerWidth, h = window.innerHeight;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // 產生隨機點作為多邊形中心
    const CELL_COUNT = 64;
    let points = [];
    for (let i = 0; i < CELL_COUNT; i++) {
      points.push({
        x: Math.random() * w,
        y: Math.random() * h,
        hue: Math.random() * 360,
        speed: Math.random() * 0.2 + 0.05
      });
    }

    function distance2(a, b) {
      let dx = a.x - b.x, dy = a.y - b.y;
      return dx*dx + dy*dy;
    }

    function draw() {
      ctx.clearRect(0, 0, w, h);

      // 動態調整每個點的色相
      for (let p of points) {
        p.hue = (p.hue + p.speed) % 360;
      }

      // 每個像素找最近的點，著色（1x1像素，提升細緻度）
      let img = ctx.createImageData(w * dpr, h * dpr);
      let data = img.data;
      for (let y = 0; y < h * dpr; y++) {
        for (let x = 0; x < w * dpr; x++) {
          let fx = x / dpr, fy = y / dpr;
          let minD = 1e9, minI = 0;
          for (let i = 0; i < points.length; i++) {
            let d = (points[i].x - fx) ** 2 + (points[i].y - fy) ** 2;
            if (d < minD) { minD = d; minI = i; }
          }
          let hue = points[minI].hue;
          let sat = 75;
          let light = 60;
          let color = hslToRgb(hue/360, sat/100, light/100);
          let idx = 4 * (y * w * dpr + x);
          data[idx] = color[0];
          data[idx+1] = color[1];
          data[idx+2] = color[2];
          data[idx+3] = 255;
        }
      }

      ctx.putImageData(img, 0, 0);

      requestAnimationFrame(draw);
    }

    // HSL to RGB helper
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s == 0) {
        r = g = b = l;
      } else {
        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        }
        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
    }

    window.addEventListener('resize', () => {
      dpr = window.devicePixelRatio || 1;
      w = window.innerWidth;
      h = window.innerHeight;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      // 重新分布點
      points = [];
      for (let i = 0; i < CELL_COUNT; i++) {
        points.push({
          x: Math.random() * w,
          y: Math.random() * h,
          hue: Math.random() * 360,
          speed: Math.random() * 0.2 + 0.05
        });
      }
    });

    draw();
  </script>
</body>
</html>
