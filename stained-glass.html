<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>首頁 - 彩繪玻璃動態背景</title>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #stained-glass-bg {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      z-index: -1;
      display: block;
    }
    h1, p { position: relative; z-index: 1; color: #222; text-shadow: 0 0 8px #fff, 0 0 2px #fff; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6.0.2/dist/d3-delaunay.min.js"></script>
</head>
<body>
  <canvas id="stained-glass-bg"></canvas>
  <div style="position:fixed;top:16px;right:24px;z-index:2;">
    <label style="color:#222;font-weight:bold;">主題：</label>
    <select id="themeSel">
      <option value="rainbow">彩虹</option>
      <option value="warm">暖色</option>
      <option value="cool">冷色</option>
      <option value="mono-blue">單色藍</option>
      <option value="mono-green">單色綠</option>
      <option value="mono-red">單色紅</option>
      <option value="mono-yellow">單色黃</option>
      <option value="mono-purple">單色紫</option>
    </select>
  </div>
  <script>
    const canvas = document.getElementById('stained-glass-bg');
    const ctx = canvas.getContext('2d');
    let dpr = window.devicePixelRatio || 1;
    let w = window.innerWidth, h = window.innerHeight;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // 產生隨機點作為多邊形中心
    const CELL_COUNT = 80;
    let points = [];
    function randomPoints() {
      points = [];
      for (let i = 0; i < CELL_COUNT; i++) {
        points.push({
          x: Math.random() * w,
          y: Math.random() * h,
          hue: Math.random() * 360,
          speed: Math.random() * 0.2 + 0.05
        });
      }
    }
    randomPoints();

    let mouse = { x: w / 2, y: h / 2 };
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = (e.clientX - rect.left) * w / rect.width;
      mouse.y = (e.clientY - rect.top) * h / rect.height;
    });

    let theme = "rainbow";
    document.getElementById('themeSel').addEventListener('change', e => {
      theme = e.target.value;
    });

    function getThemeHue(baseHue, idx) {
      switch(theme) {
        case "warm":
          return 20 + 40 * Math.sin(idx * 0.7 + baseHue / 180 * Math.PI);
        case "cool":
          return 180 + 60 * Math.sin(idx * 0.8 + baseHue / 180 * Math.PI);
        case "mono-blue":
          return 210 + 10 * Math.sin(idx + baseHue / 30); // 輕微變化
        case "mono-green":
          return 120 + 10 * Math.sin(idx + baseHue / 30);
        case "mono-red":
          return 0 + 10 * Math.sin(idx + baseHue / 30);
        case "mono-yellow":
          return 50 + 10 * Math.sin(idx + baseHue / 30);
        case "mono-purple":
          return 280 + 10 * Math.sin(idx + baseHue / 30);
        default: // 彩虹
          return baseHue;
      }
    }

    function drawVoronoi() {
      ctx.clearRect(0, 0, w, h);

      // 動態調整每個點的色相
      for (let p of points) {
        p.hue = (p.hue + p.speed) % 360;
      }

      // 用 d3-delaunay 計算 Voronoi
      const delaunay = d3.Delaunay.from(points, d => d.x, d => d.y);
      const voronoi = delaunay.voronoi([0, 0, w, h]);

      for (let i = 0; i < points.length; i++) {
        const cell = voronoi.cellPolygon(i);
        if (!cell) continue;
        let p = points[i];
        // 主題色調
        let hue = getThemeHue(p.hue, i);
        let sat = 75;
        let light = 60;

        // 互動：滑鼠靠近時加亮
        let dx = p.x - mouse.x, dy = p.y - mouse.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let maxDist = Math.min(w, h) * 0.25;
        if (dist < maxDist) {
          let boost = 25 * (1 - dist / maxDist);
          light = Math.min(100, light + boost);
        }

        let color = hslToRgb(hue/360, sat/100, light/100);

        ctx.beginPath();
        ctx.moveTo(cell[0][0], cell[0][1]);
        for (let j = 1; j < cell.length; j++) {
          ctx.lineTo(cell[j][0], cell[j][1]);
        }
        ctx.closePath();
        ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
        ctx.fill();

        // 畫圓滑黑邊
        ctx.save();
        ctx.strokeStyle = "#222";
        ctx.lineWidth = 2.2;
        ctx.shadowColor = "#000";
        ctx.shadowBlur = 2;
        ctx.stroke();
        ctx.restore();
      }

      requestAnimationFrame(drawVoronoi);
    }

    // HSL to RGB helper
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s == 0) {
        r = g = b = l;
      } else {
        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        }
        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
    }

    window.addEventListener('resize', () => {
      dpr = window.devicePixelRatio || 1;
      w = window.innerWidth;
      h = window.innerHeight;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      randomPoints();
    });

    drawVoronoi();
  </script>
</body>
</html>